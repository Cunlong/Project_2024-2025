# -*- coding: utf-8 -*-
"""RelExtract.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M7vyCcDyI5R2fr9RI04JM2mIHXrwyUWV
"""

from google.colab import drive
drive.mount('/content/drive')

"""Llama-3"""

#!/usr/bin/env python
# coding: utf-8

import os
import difflib
import csv
import argparse
import datetime
from transformers import pipeline, AutoModelForCausalLM, AutoTokenizer
import torch
import time

REQUEST_REPEAT_RATE_UTILS = 3
REQUEST_REPEAT_RATE = 1

# Initialize the model and tokenizer
model_path = "/content/drive/MyDrive/meta-llama-3.1-8B-instruct"
tokenizer = AutoTokenizer.from_pretrained(model_path, use_fast=False)
model = AutoModelForCausalLM.from_pretrained(
    model_path,
    device_map="cuda",
    torch_dtype=torch.bfloat16,
    trust_remote_code=False
)
pipe = pipeline(
    "text-generation",
    model=model,
    tokenizer=tokenizer
)

"""Mistral"""

import os
import difflib
import csv
import argparse
import datetime
import time
from transformers import AutoTokenizer, AutoModelForCausalLM, pipeline
import torch

model_path = "/content/drive/My Drive/mistral_models/7B-Instruct-v0.3"

tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)
model = AutoModelForCausalLM.from_pretrained(
    model_path,
    torch_dtype=torch.bfloat16,
    device_map="auto",
    trust_remote_code=True
)


pipe = pipeline("text-generation", model=model, tokenizer=tokenizer)

"""Load Dataset"""

import json

with open('/content/drive/MyDrive/radgraph/test.json', 'r') as file:
    data = json.load(file)

import csv

def rewrite_values(code):
    mapping = {
        "ANAT-DP": "Anatomy",
        "OBS-DP": "Observation",
        "OBS-U": "Observation",
        "OBS-DA": "Observation"
    }
    return mapping.get(code, "Unknown code")


prompt_template = """
You are an expert in clinical natural language processing.
Based on the information provided, determine the relationship between two entities in a radiology sentence.

Here are the definitions of the entities and possible relationships:

Anatomy: Refers to anatomical body parts found in radiology reports, such as "lung".
Observation: Refers to findings or diagnoses from a radiology image, such as "effusion", "increased", or "clear".

Possible relationships:

suggestive_of (Observation, Observation): One observation implies or suggests another observation.
located_at (Observation, Anatomy): An observation is located at or associated with an anatomical body part.
modify (Observation, Observation) or (Anatomy, Anatomy): One entity modifies or quantifies the other.

Here are some examples:

Sentence: "There is a pleural effusion in the left lung."
Entities: "effusion" (Observation), "lung" (Anatomy)
Answer:located_at.


Sentence: "Severe scoliosis is causing asymmetry of the ribcage."
Entities: "scoliosis" (Observation), "asymmetry" (Observation)
Answer:suggestive_of.


Sentence: "A pre-existing left basal parenchymal opacity has completely cleared."
Entities: "left" (Anatomy), "basal" (Anatomy)
Answer:modify.


Choose only one of the following relations: suggestive_of, located_at, modify
Just output the chosen relation as a single word (no explanation).

Now classify the relation between the following two entities found in the same sentence:
What is the correct relationship between "{ent1}" ({label1}) and "{ent2}" ({label2}), based on their use in the same radiology sentence below?
"{note}"



"""


import re


golden_tag_list = list()
predicted_tag_list = list()

def extract_relation(response):
    if isinstance(response, list):
        response = response[0]
    response = response.lower().strip().replace("\n", "").replace(" ", "")
    matches = re.findall(r"(suggestive_of|located_at|modify)", response)
    if matches:
        return matches[-1]
    return "unknown"


for i, d in enumerate(data):

  if i > 10:
    break
  ld = data[d]
  #for dev/train dataset
  #ent = ld['entities']
  #for test dataset
  ent = ld['labeler_1']['entities']

  relations = [(e, ent[e]['relations']) for e in ent.keys()]

  final_rels = list()
  for rel in relations:
    rel_init = ent[rel[0]]
    for local_rel in rel[1]:
      rel_2nd = ent[local_rel[1]]
      final_rels.append((rel_init['tokens'], rewrite_values(rel_init['label']), rel_2nd['tokens'], rewrite_values(rel_2nd['label']), local_rel[0]))

  print(final_rels)

  for rel in final_rels:
    print(rel)
    prompt = prompt_template.format(ent1=rel[0], label1=rel[1], ent2=rel[2], label2=rel[3], note=ld['text'])
    print(prompt)

    golden_tag_list.append(rel[4])

    messages = []
    messages.append({"role": "user", "content": prompt})

    outputs = pipe(messages, max_new_tokens=50)
    #response = outputs[0]["generated_text"][-1]["content"]
    response = extract_relation(outputs[0]["generated_text"][-1]["content"])
    predicted_tag_list.append(response)
    print(response)
    #response = outputs[0]["generated_text"][-1]["content"].lower()

    #predicted_tag_list.append(response.strip())
    #print(response)


print(golden_tag_list)
print(predicted_tag_list)

"""Evaluation"""

from sklearn.metrics import f1_score

micro_f1 = f1_score(golden_tag_list, predicted_tag_list, average='micro')
macro_f1 = f1_score(golden_tag_list, predicted_tag_list, average='macro')

print(f"Micro F1 Score: {micro_f1:.4f}")
print(f"Macro F1 Score: {macro_f1:.4f}")

labels = sorted(set(golden_tag_list + predicted_tag_list))

f1 = f1_score(golden_tag_list, predicted_tag_list, labels=labels, average=None)

for label, score in zip(labels, f1):
    print(f"Label: {label}, F1 Score: {score:.4f}")